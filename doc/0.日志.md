
## setAsyncState
与setState的区别，是
1. 一个promise取代initialState
1. 除了初始状态外，应有pending,error,data三个状态，data存放数据
  或者一个提供一个resolve函数，带data参数
1. 根据状态返回component或者进度、错误、权限判断
  因此这里似乎以类似中间件机制较为合适？
  如果没有pending，没有错误，则表示执行完毕，这时应该有data属性
1. 在componentDidMounted，执行promise
1. 
## 因此需要有状态模板这类
1. 初始状态如何？
1. 默认的名称
1. 默认的字段名称
1. 有哪些不属于状态的中间变量、哪些action、哪些业务函数(使用action但完成功能)
  理论上action与实例无关
  业务函数若调用action，同样与实例无关。

因此：
1. 静态的initialState
1. 静态的action
1. 动态的业务函数(针对状态)
1. 构造函数要提供字段名、状态名、store名
  由此确定其使用哪个
1. 动态的setComp(comp),用于与状态树关联

## 对于一个setState，也就是一个组件存储多个状态的情形
makeState可以胜任
只要提供合适的initialState即可

但setState的时候应该带上字段
这种情形下，我们可以提供一个帮助函数setFieldState=(field)=>(prevState,props)=>
这样简单的解决问题

这里的问题是action的组织，我们可以简单的用函数
也可以考虑用类的静态函数，这样无需记忆和太多的import
也可以考虑提供类的实例，这样可以处理多个结构相同、action相同的不同状态




# 1月25日 周4

## 使用状态的场景
1. 使用较多的:我们定义一些全局的状态，整个app可能使用，或者某个组件树可用
  setState处理re-render
  对于多个状态，可以制作含有fieldName的共享同一个组件
1. 其次:我们为一个组件定义状态，比如form和预先载入数据的场景
  这里我们或许仅仅需要这些状态，让form可以编辑
  也可能连状态都不需要，将状态通过属性传递给组件
  这种情形，则仅仅是下级组件，通过属性使用
1. 比较少:我们可能提取第三方组件的状态
1. 组件需要从服务端获取数据：容器模式，一次性读入之后，除非刷新不再读入。同时保留action,必要的时候手动的刷新。
  makeAsycState...属性可提供refresh这类函数，用于再次读取，有需要的话可以定时刷新。
