
# 1月28日 周日

makeState
makeAsyncState...或者利用属性融合到makeState

换言之
属性action存放一组action
属性action.componentDidMount 存放需要预先载入的action
比如既然存在loadUser action，则action.componentDidMount=action.loadUser

action可以组合，以便处理分字段的问题
比如user,filedName可以设置
同时new user为其action
合并后同样有fieldName，换言之，与其component绑定


增加action概念并不合适，人为的复杂化
同时，异步分开处理也不妥，makeState加上生命周期属性
<app >
hoc可以使用属性来传递参数，而参数本身也可以有默认值,因此makeState本身也可以不带参数，利用属性
目前makeState的参数，最简化的也有三个，即initialState,stateName,storeObject
我们或许也需要一个拥有字段属性的makeState,即多个initialState以字段形式，共存于一个组件的state

一个重要的问题，是异步处理，包括两种:
1. 预先载入
1. 类似按钮事件中执行
makeAsyncState:
1. 给下级组件传递状态和action
1. 保存promise，可以手动的refresh，可以点击按钮执行
promise可以用object属性的形式，存于属性中
{
  loadUserState:()=>{}，
  saveToServer:...
}
预先载入在didmounted
点击执行则runAsync...涉及到按钮，通常需要处理进度、错误、成功、定时恢复等

异步之后是fetch和upload
fetch我们使用标准的fetch，以get和post为主
而upload则使用xhr,方便进度处理。

因此makeAsyncState或许需要处理进度。。不单纯是pending状态。

## 关于auth
auth实际上是user对象
状态为id,token,name等
user对象本身是一个异步的状态，通过login或autoLogin获取，一般情况下id是null
register等，也是异步的action 


## 关于rbac

## field 状态
一般是(state)=>传递给setState
如果有field则field(filedName)(action)传递给setState
field来自参数即可，比如router
store.app.router,app是状态，router则是状态中的一个字段

## promise问题

换言之，makeState若有promise属性
则在componentDidMonted中执行
若有promisePending、promiseError、promiseEmpty和isEmpty属性、promiseCan属性
则分别做相应的处理。
这样makeState无需改变，就可以处理异步操作
同时要测试，promise的refresh，以及保存promise供buuton点击后执行。
因此，需要一个loader组件，该组件使用makeState封装，处理loadPromise、loadProgress、loadError、loadEmpty、loadPending等
状态包括pending、error、data属性名、
<loading dataField={null}>
此时得到的数据直接传入状态，如果为默认的'resolved',则状态中的state.resolved是得到的数据
如果rejected

loading hoc
https://github.com/alakarteio/hoc-react-loader
抽象的技巧:这里的hoc利用属性作为参数，api相当简化
// loading indicator will be displayed only after 200ms
export default loader({ print: ['data'], delay: 200 })(MyComponent)

https://github.com/MOHAMMADArsalan/React-Projects/blob/53e9ec4f1b5c380da9e9ee46bdd3aa2f47417fb2/Blood%20App/src/HOC/LoadingHoc.jsx
这里判断某个属性是否为空：
import React, { Component } from "react";
import CircularProgress from 'material-ui/CircularProgress';

const LoadingHOC = (propName) => (WrapperComponent) => {
    return class LoadingHOC extends Component {
        isEmpty(prop) {
            return (
                prop === null || prop === undefined ||
                (prop.hasOwnProperty('length') && prop.length === 0) ||
                (prop.constructor === Object && Object.keys(prop).length === 0)
            )
        }
        render() {
            return this.isEmpty(this.props[propName]) ?

                <CircularProgress style={{ marginTop: 25, marginLeft: 50 }} />

                : <WrapperComponent {...this.props} />
        }
    }
}
export default LoadingHOC;

这里是文件上传进度条，可显示百分比
https://github.com/georgeOsdDev/react-fileupload-progress

这个则是按钮，点击显示进度，失败显示失败按钮，延时后恢复
https://github.com/mathieudutour/react-progress-button



## setAsyncState
与setState的区别，是
1. 一个promise取代initialState
1. 除了初始状态外，应有pending,error,data三个状态，data存放数据
  或者一个提供一个resolve函数，带data参数
1. 根据状态返回component或者进度、错误、权限判断
  因此这里似乎以类似中间件机制较为合适？
  如果没有pending，没有错误，则表示执行完毕，这时应该有data属性
1. 在componentDidMounted，执行promise
1. 
## 因此需要有状态模板这类
1. 初始状态如何？
1. 默认的名称
1. 默认的字段名称
1. 有哪些不属于状态的中间变量、哪些action、哪些业务函数(使用action但完成功能)
  理论上action与实例无关
  业务函数若调用action，同样与实例无关。

因此：
1. 静态的initialState
1. 静态的action
1. 动态的业务函数(针对状态)
1. 构造函数要提供字段名、状态名、store名
  由此确定其使用哪个
1. 动态的setComp(comp),用于与状态树关联

## 对于一个setState，也就是一个组件存储多个状态的情形
makeState可以胜任
只要提供合适的initialState即可

但setState的时候应该带上字段
这种情形下，我们可以提供一个帮助函数setFieldState=(field)=>(prevState,props)=>
这样简单的解决问题

这里的问题是action的组织，我们可以简单的用函数
也可以考虑用类的静态函数，这样无需记忆和太多的import
也可以考虑提供类的实例，这样可以处理多个结构相同、action相同的不同状态




# 1月25日 周4

## 使用状态的场景
1. 使用较多的:我们定义一些全局的状态，整个app可能使用，或者某个组件树可用
  setState处理re-render
  对于多个状态，可以制作含有fieldName的共享同一个组件
1. 其次:我们为一个组件定义状态，比如form和预先载入数据的场景
  这里我们或许仅仅需要这些状态，让form可以编辑
  也可能连状态都不需要，将状态通过属性传递给组件
  这种情形，则仅仅是下级组件，通过属性使用
1. 比较少:我们可能提取第三方组件的状态
1. 组件需要从服务端获取数据：容器模式，一次性读入之后，除非刷新不再读入。同时保留action,必要的时候手动的刷新。
  makeAsycState...属性可提供refresh这类函数，用于再次读取，有需要的话可以定时刷新。
